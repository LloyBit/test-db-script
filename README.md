# DB-script

## Главное

### Описание

Скрипт который инициализирует БД+таблицу(команда 1) и генерирует значения туда(команда 4). При необходимости можно дропнуть БД(команда 0) для удобства тестирования.
Можно записывать свои строки в БД(команда 2) и делать вывод уникальных значений (команда 3). 
И самое главное можно выводить фильтрованные значения(по ТЗ нужно было хардкодить фамилии на F и мужчин) + оптимизировать запросы(команды 5 и 6 соответственно)  

### Запуск в Docker (интерактивный режим)

```bash
docker compose run --rm db-script
```

Вывод в консоль, CLI loop с выбором (1–7, 0, q).

### Результат оптимизации

В качестве средства оптимизации я решил использовать составные индексы. PostgreSQL при выполнении запросов анализирует имеющиеся индексы и сам выбирает эффективный индекс. Таким образом не меняя реализацию 5-ой комманды мы оптимизировали время выполнения запроса.
Объем по которому проводился поиск: "Total rows: 1000100"

```bash
> 7
Число выполнений: 100
Медиана: 0.03311518450004769
> 6
Составной индекс (gender, full_name) создан.
Execution time for run: 0:00:02.023279
> 7
Число выполнений: 100
Медиана: 0.01836459499998
```

Как видно из вывода медианное время выполнения уменьшилось на ~40% после выполнения оптимизации.

## Допущения

### Комманда для удаления таблицы

Я добавил незаявленную комманду для удаления таблицы users как команду 0. Она была невероятно удобна при тестировке других комманд поэтому я, на всякий случай, оставил ее для "продакшена"

### Отчество = второе имя

ФИО в БД представляет собой запись вида: "Фамилия Имя Имя". Это обусловлено тем что нет эффективного способа генерации русского отчества на латинице. Аналогично с генерацией русских имен и фамилий на латинице.
Поэтому вместо патронима(отчества) я взял второе имя(middle name).
Я считаю это оправданным допущением потому что в реальной среде программа будет получать ФИО и валидировать его, не занимаясь его генерацией. Также не хотелось бы удваивать объем кода и времени выполнения ради не самой значимой информации.

### Уникальных записей слишком много

Поскольку генерация представляет собой комбинирование элементов массивов(векторов) то уникальных значений может получаться довольно много. Балансируя между равномерным распределением первой буквы фамилии и повышением числа неуникальных записей для тестирования 3 комманды я пришел к ~80% повторяющихся записей. Но все равно этих записей очень много, поэтому в отображении я использовал пагинацию. И красивое оформление tabulate
